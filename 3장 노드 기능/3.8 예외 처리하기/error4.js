// 이번에는 정말 예측이 불가능한 에러를 처리하는 방법을 알아보겠습니다.

// process 객체에 uncaughtException 이벤트 리스너를 달았습니다.
// 처리하지 못한 에러가 발생했을 때
// 이벤트 리스너가 실행되고 프로세스가 유지됩니다.
// 이 부분이 없다면 위 예제에서는 setTimeout이 실행되지 않습니다.
process.on("uncaughtException", (err) => {
  console.error("예기치 못한 에러", err);
});

setInterval(() => {
  throw new Error("서버를 고장내주마!");
}, 1000);

setTimeout(() => {
  console.log("실행됩니다");
}, 2000);

// 실행 후 1초 만에 setInterval에서 에러가 발생하여
// 프로세스가 멈추기 때문입니다.
// 하지만 uncaughtException 이벤트 리스너가 연결되어 있으므로
// 프로세스가 멈추지 않습니다.

// try/catch로 처리하지 못한 에러가 발생했지만
// 코드가 제대로 실행되었습니다.

// 어떻게 보면 uncaughtException 이벤트 리스너로
// 모든 에러를 처리할 수 있을 것처럼 보입니다.
// 실제로 uncaughtException의 콜백 함수에 에러 발생 시
// 복구 작업을 하는 코드를 넣어둔 사람을 본 적도 있습니다.
// 하지만 노드 공식 문서에서는 uncaughtException 이벤트를
// 최후의 수단으로 사용할 것을 명시하고 있습니다.
// 노드는 uncaughException 이벤트 발생 후 다음 동작이
// 제대로 동작하는지를 보증하지 않습니다.
// 즉, 복구 작업 코드를 넣어 두었더라도 그것이 동작하는지 확신할 수 없습니다.

// 따라서 uncaughtException은 단순히 에러 내용을 기록하는 정도로 사용하고,
// 에러를 기록한 후 process.exit()으로 프로세스를 종료하는 것이 좋습니다.
// 에러가 발생하는 코드를 수정하지 않는 이상,
// 프로세스가 실행되는 동안 에러는 계속 발생할 것입니다.

// 서버 운영은 에러와의 싸움입니다.
// 모든 에러 상황에 대비하는 것이 최선이지만,
// 시간이나 비용, 인력 등의 제약으로
// 미처 대비하지 못한 에러가 발생할 수 있습니다.
// 따라서 에러 발생 시 철저히 기록(로깅)하는 습관을 들이고,
// 주기적으로 로그를 확인하면서 보완해나가야 합니다.
// 운영 중인 서버가 에러로 인해 종료되었을 때
// 자동으로 재시작하는 방법은 15.1.5절에서 알아봅니다.
